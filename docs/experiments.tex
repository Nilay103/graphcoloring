\section{Experimentación}

Dada la cantidad de vértices, los grafos se generan en el formato estándar DIMACS \footnote{Para ver algunos ejemplos del formato: http://mat.gsia.cmu.edu/COLOR/instances.html}. El generador toma como parámetro la densidad del grafo. Dada una clique con esa cantidad de vértices, se elijen vértices al azar hasta que se llega a la densidad deseada. Debido a que estas instancias están diseñadas para coloreo de grafos, asignamos los vértices de forma uniforme en el total de particiones pasado por parámetro a nuestro programa de coloreo particionado.

Por cuestiones de tiempo, cada uno de los experimientos CPLEX fue ejecutado sin límite de cantidad de threads, con un procesador Intel(R) Core(TM) i7-3610QM CPU @ 2.30GHz y 16GB de memoria RAM.

\subsection{Eliminación de simetría}

Al igual que el problema de coloreo de grafos, el problema del coloreo particionado de grafos presenta una gran cantidad de soluciones simétricas. De no romper la simetría del problema, los algoritmos tendrían un espacio de búsqueda mucho mayor, moviéndose por soluciones que, siendo computacionalmente distintas, en la práctica se trata de la misma. Esto afecta el tiempo de ejecución de forma considerable a medida que crece el tamaño del problema. Para romper la simetría en nuestro problema, en la sección \ref{simetria} mostramos cómo utilizamos la clásica condicion de coloreo de que los colores se deben utilizar en orden. Este fenómeno se puede ver en el siguiente gráfico:

\begin{figure}[h]
\centering
\includegraphics[scale=0.7]{img/2-symmetry_v25_p5_l40_t1_b0.png}
\caption{Tiempo de resolución del modelo incluyendo o no eliminación de simetría.}
\end{figure}

Esto nos brinda la noción sumamente relevante de la importancia y efectividad de romper simetría al realizar la formulación de un LP. Cabe mencionar que existen muchas otras estrategias o expresiones para disminuir aun más el grado de simetría de la formulación. La escogida bajo ninguna circunstancia debe ser considerada la mejor posible.

\pagebreak

\subsection{Efectividad de las familias de desigualdades}

La idea de este experimento es comparar las diferentes estrategias de planos de corte. Para ello, se eligió a 40 como la cantidad de cortes de cada tipo que se podían agregar, con una sola iteración:
% en cada iteración se podían agregar hasta 40 cortes?

\begin{figure}[h]
  \centering
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/5-cuts_v40_p20_i1_l40_t1_b0.png}
    \caption{Estrategias de planos de corte (tiempo)}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/5-cuts_v40_p20_i1_l40_t1_b0_nodes.png}
    \caption{Estrategias de planos de corte (nodos recorridos)}
  \end{minipage}
\end{figure}

Lo primero que podemos observar es que no siempre hay una estrategia ganadora por sobre las otras. Se observa con claridad una dependencia entre la densidad del grafo y la estrategia que tuvo mejores resultados. Cuanto más denso, más cliques nuestra heurística debería encontrar, y a priori uno esperaría que los tiempos mejoren. Esto no sucede, de hecho agregar las restriciones de clique empeora el tiempo de ejecución con respecto al resultado de utilizar B\&B. También podemos observar que un mejor tiempo de ejecución no necesariamente implica que se recorren menos nodos en árbol de enumeración. En contra de lo que esperábamos inicialmente, las desigualdades de agujero impar parecen funcionar bien, aunque por supuesto esto se podría constatar con mayor peso de llevar a cabo una experimentación mas exhaustiva.

\subsection{Efecto de aumentar el número de particiones}

A medida que aumentamos el número de particiones, el problema comienza a parecerse más a uno de coloreo. Dado que las desigualdades que implementamos son clásicas de coloreo, es de esperar que la performance mejore a medida que aumenta el número de particiones \cite{coloring}. Para Cut \& Branch, sólo utilizamos los mejores 40 cortes de clique con una iteración. A medida que aumenta el número de particiones, podemos observar cómo la ganancia del corte es mayor.

\begin{figure}[h]
  \centering
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/3-partitions_v30_d50_i1_co0_l40_t1_b0.png}
    \caption{Tiempo de ejecucion a medida que aumenta el numero de particiones.}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/3-partitions_v30_d50_i1_co0_l40_t1_b0_nodes.png}
    \caption{Nodos recorridos a medida que aumenta el numero de particiones.}
  \end{minipage}
\end{figure}

\pagebreak

\subsection{Efecto de aumentar la densidad del grafo}

\begin{figure}[h]
  \centering
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/1-bb_vs_bc_v20_p10_i1_co0_l40_t1_b0.png}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/1-bb_vs_bc_v40_p10_i1_co0_l40_t1_b0.png}
  \end{minipage}
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/1-bb_vs_bc_v60_p10_i1_co0_l40_t1_b0.png}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/1-bb_vs_bc_v100_p10_i1_co0_l40_t1_b0.png}
  \end{minipage}
	\caption{Efecto de aumentar la densidad del grafo.}
\end{figure}

A medida que aumenta la densidad del grafo, el problema de coloreo se vuelve sin duda más difícil. En los casos donde el número de particiones es mayor en relación al numero de vértices, Branch \& Cut con 1 iteración y 40 desigualdades violadas parece funcionar mejor. Esto no sucede en grafos esparsos, donde Branch \& Bound puro tiene un menor tiempo de ejecución.

\pagebreak

\subsection{Efecto de aumentar la cantidad de restricciones incorporadas por iteración}

Para todos nuestros experimentos en general utilizamos sólo 1 iteración con un límite de 40 desigualdades por familia. La idea de este experimento es evaluar esta configuración. Para ello, utilizamos un grafo con 40 vértices y 20 particiones.

\begin{figure}[h]
  \centering
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/6-thresholds_v40_p20_i1_t1_b0.png}
    \caption{Tiempo de ejecución al incrementar el número de restricciones incorporadas.}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/6-thresholds_v40_p20_i1_co2_t1_b0_nodes.png}
    \caption{Nodos recorridos al incrementar el número de restricciones incorporadas.}
  \end{minipage}
\end{figure}

Como podemos observar, agregar más restricciones no es siempre ventajoso. En un principio, agregar restricciones parece mejorar la ejecución del C\&B, pero ya a partir de 40 el tiempo de ejecución empeora de forma abrupta para las cliques. Esto no sucede para las restricciones de agujero impar. Nuevamente, esto se puede deber a que nuestra heurística de clique no es lo suficientemente buena.

\subsection{Efecto de aumentar la cantidad de iteraciones de planos de corte}

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{img/7-iterations_v40_p10_l40_t1_b0.png}
\caption{Tiempo de ejecución al aumentar la cantidad de iteraciones de planos de corte.}
\end{figure}

Como podemos ver, aumentar el numero de iteraciones de planos de corte no necesariamente mejora el tiempo de ejecución. En cada iteración lo que hacíamos era generar una familia en función de la solución de la relajación del problema, y luego agregar las \textit{mejores} restricciones. En relación a la sección anterior, esto también esta relacionado con el $threshold$ que elegimos para hacer la experimentación.

\pagebreak

\subsection{Comparación B\&B, C\&B, CPLEX default}

\begin{figure}[h]
  \centering
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/8-compare_v20_p10_i1_l40_t1_b0.png}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/8-compare_v20_p20_i1_l40_t1_b0.png}
  \end{minipage}
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/8-compare_v40_p10_i1_l40_t1_b0.png}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/8-compare_v40_p20_i1_l40_t1_b0.png}
  \end{minipage}
	\caption{Comparacion B\&B, C\&B, CPLEX default para diferentes grafos.}
\end{figure}

Dado que el CPLEX por default utiliza cortes de Gomory y preprocesamiento de variables, no nos sorprende que en general sea superior a nuestras otras estrategias para grafos densos. Una propuesta interesante podría ser repetir esta experimentación permitiendo los cortes y el preprocesamiento para todas nuestras estrategias. Otra observación, el gráfico superior derecho es el caso de coloreo de grafos, dado que cada vértice pertenece a una partición diferente. Aquí podemos ver que las desigualdades de clique son sumamente útiles. 

\pagebreak

\subsection{Estrategias de recorrido del árbol de enumeración
y selección de variable de branching}

Existen muchas estrategias de recorrido del árbol de enumeración. En este trabajo solo analizaremos DFS y BBS. DFS (Depth First Search) recorre el árbol de enumeración de B\&B primero en profundidad. Por otro lado, BBS (Best Bound Search) recorre el árbol de enumeración utilizando alguna estrategia para intentar buscar una buena cota lo mas rápido posible. En general se utilizan estrategias heurísticas. En el caso de CPLEX, dado un nodo padre se calcula la solución a la relajación de todos sus hijos y luego se continua recorriendo el nodo con el mayor resultado de la función objetivo. \footnote{http://www-01.ibm.com/support/knowledgecenter/SSSA5P\_12.6.1/ilog.odms.cplex.help/CPLEX/Parameters/topics/NodeSel.html}.

Ambas estrategias son sumamente ventajosas ya que permiten obtener una cota superior a la solución final para utilizar de poda al hacer backtracking sobre el árbol de enumeración. Dado que no utilizamos heurísticas iniciales, esta estrategia parece razonable. 

Por otro lado, las estrategias de selección de variable buscan encontrar cual es la mejor variable sobre la cual hacer branching. Hay muchas reglas, como por ejemplo \textit{max/min infeasibility}. Mientras que la regla de \textit{minimum infeasibility} busca hacer branching sobre mas cercana al entero, la regla de \textit{maximum infeasibility} busca hacer exactamente lo contrario \footnote{http://www-01.ibm.com/support/knowledgecenter/SS9UKU\_12.4.0/com.ibm.cplex.zos.help/Parameters/topics/VarSel.html}.

En esta sección analizaremos 4 combinaciones de estrategias de recorrido del árbol de enumeración y selección de variable de branching para B\&B puro y C\&B con cortes de clique, 1 iteración y $threshold = 30$. Las combinaciones que analizaremos son: DFS + MAXINFEAS, DFS + MININFEAS, BESTBOUND + MAXINFEAS, BESTBOUND + MININFEAS.

\begin{figure}[h]
  \centering
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/9-tree_v60_p10_i1_l30_s1.png}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/9-tree_v60_p10_i1_l30_s1_nodes.png}
  \end{minipage}
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/9-tree_v60_p10_i1_l30_s2.png}
  \caption{Tiempo de ejecución dependiendo de la estrategias de recorrido y selección de variable.}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.49\textwidth}
    \includegraphics[width=\textwidth]{img/9-tree_v60_p10_i1_l30_s2_nodes.png}
  \caption{Nodos recorridos dependiendo de la estrategias de recorrido y selección de variable.}
  \end{minipage}
\end{figure}

Como podemos observar, en general C\&B tiene tiempos de ejecución menores y a su vez recorre menos nodos. La mejor estrategia para este problema parece ser BESTBOUND + MAXINFEAS. CPLEX utiliza por default BESTBOUND, aunque utiliza una heurística para elegir la variable de branching. 

\subsection{Instancias DIMACS}

Las instancias DIMACS son comúnmente utilizadas en la literatura como instancias de benchmarking. A continuación mostramos nuestros tiempos de ejecución con B\&B y B\&C utilizando 1 iteración y $threshold = 30$ con solo desigualdades de clique. A su vez, ambas utilizan el recorrido del árbol de enumeración dado por default en CPLEX.

Cada tabla utiliza un numero de particiones diferente. Dado que las instancias DIMACS no tienen un numero de partición debido a que se utilizan normalmente para coloreo, asignamos uno nosotros y luego dividimos los vértices en orden en las diferentes particiones de forma uniforme.

Tomamos como tiempo de ejecucion limite 10 minutos, y reportamos el numero de colores encontrado por B\&B hasta ese momento. En todos los casos, B\&B y B\&C coincidieron con el numero de colores utilizados, por lo que los reportamos solo en una columna.

\begin{table}[H]
\centering
\caption{Benchmark con 10 particiones}
\begin{tabular}{|l|r|r|r|r|r|}
\hline
Problem & \multicolumn{1}{l|}{n} & \multicolumn{1}{l|}{m} & \multicolumn{1}{l|}{Tiempo tomado por B\&B (secs)} & \multicolumn{1}{l|}{Tiempo tomado por B\&C (secs)} & \multicolumn{1}{l|}{Colores utilizados} \\ \hline
anna & 138 & 493 & 0.04 & 0.50 & 1 \\ \hline
david & 87 & 406 & 0.02 & 0.29 & 1 \\ \hline
fpsol2.i.1 & 496 & 11654 & 0.51 & 8.71 & 1 \\ \hline
fpsol2.i.2 & 451 & 8691 & 0.44 & 7.66 & 1 \\ \hline
fpsol2.i.3 & 425 & 8688 & 0.45 & 8.15 & 1 \\ \hline
games120 & 120 & 638 & 0.04 & 0.32 & 1 \\ \hline
homer & 561 & 1629 & 0.11 & 0.72 & 1 \\ \hline
huck & 74 & 301 & 0.02 & 0.10 & 1 \\ \hline
inithx.i.1 & 864 & 18707 & 0.79 & 9.66 & 1 \\ \hline
inithx.i.2 & 645 & 13979 & 0.59 & 6.53 & 1 \\ \hline
inithx.i.3 & 621 & 13969 & 0.59 & 6.16 & 1 \\ \hline
jean & 80 & 254 & 0.02 & 0.10 & 1 \\ \hline
le450\_15a & 450 & 8168 & 0.31 & 14.68 & 1 \\ \hline
le450\_15b & 450 & 8169 & 0.35 & 15.68 & 1 \\ \hline
le450\_15c & 450 & 16680 & 0.64 & 36.05 & 1 \\ \hline
le450\_15d & 450 & 16750 & 0.83 & 38.00 & 1 \\ \hline
le450\_25a & 450 & 8260 & 0.34 & 24.95 & 1 \\ \hline
le450\_25b & 450 & 8263 & 0.33 & 15.41 & 1 \\ \hline
le450\_25c & 450 & 17343 & 0.70 & 42.17 & 1 \\ \hline
le450\_25d & 450 & 17425 & 0.70 & 39.60 & 1 \\ \hline
le450\_5a & 450 & 5714 & 0.27 & 8.19 & 1 \\ \hline
le450\_5b & 450 & 5734 & 0.30 & 13.78 & 1 \\ \hline
le450\_5c & 450 & 9803 & 0.46 & 29.12 & 1 \\ \hline
le450\_5d & 450 & 9757 & 0.47 & 33.13 & 1 \\ \hline
miles1000 & 128 & 3216 & 8.81 & 7.77 & 2 \\ \hline
miles1500 & 128 & 5198 & 10 min & 10 min & 3 \\ \hline
miles250 & 128 & 387 & 0.03 & 0.24 & 1 \\ \hline
miles500 & 128 & 1170 & 0.06 & 0.54 & 1 \\ \hline
miles750 & 128 & 2113 & 0.32 & 2.73 & 1 \\ \hline
mulsol.i.1 & 197 & 3925 & 0.15 & 2.20 & 1 \\ \hline
mulsol.i.2 & 188 & 3885 & 0.14 & 2.01 & 1 \\ \hline
mulsol.i.3 & 184 & 3916 & 0.16 & 3.02 & 1 \\ \hline
mulsol.i.4 & 185 & 3946 & 0.15 & 4.37 & 1 \\ \hline
mulsol.i.5 & 186 & 3973 & 0.15 & 3.42 & 1 \\ \hline
myciel2 & 32766 & 0 & 4.37 & 110.76 & 1 \\ \hline
myciel3 & 11 & 20 & 0.01 & 0.01 & 3 \\ \hline
myciel4 & 23 & 71 & 0.01 & 0.02 & 1 \\ \hline
myciel5 & 47 & 236 & 0.01 & 0.04 & 1 \\ \hline
myciel6 & 95 & 755 & 0.04 & 0.29 & 1 \\ \hline
myciel7 & 191 & 2360 & 0.09 & 1.75 & 1 \\ \hline
queen10\_10 & 100 & 1470 & 0.12 & 0.61 & 1 \\ \hline
queen11\_11 & 121 & 1980 & 0.18 & 1.03 & 1 \\ \hline
queen12\_12 & 144 & 2596 & 0.36 & 2.29 & 1 \\ \hline
queen13\_13 & 169 & 3328 & 0.44 & 2.73 & 1 \\ \hline
queen14\_14 & 196 & 4186 & 0.18 & 5.05 & 1 \\ \hline
queen15\_15 & 225 & 5180 & 0.23 & 7.02 & 1 \\ \hline
queen16\_16 & 256 & 6320 & 0.23 & 8.62 & 1 \\ \hline
queen5\_5 & 25 & 160 & 0.06 & 0.14 & 3 \\ \hline
queen6\_6 & 36 & 290 & 0.12 & 0.54 & 2 \\ \hline
queen7\_7 & 49 & 476 & 0.12 & 0.41 & 2 \\ \hline
queen8\_12 & 96 & 1368 & 3.54 & 3.96 & 2 \\ \hline
queen8\_8 & 64 & 728 & 0.26 & 0.64 & 2 \\ \hline
queen9\_9 & 81 & 1056 & 1.76 & 2.54 & 2 \\ \hline
school1 & 385 & 19095 & 1.17 & 90.04 & 1 \\ \hline
school1\_nsh & 352 & 14612 & 0.83 & 46.13 & 1 \\ \hline
zeroin.i.1 & 211 & 4100 & 0.16 & 4.87 & 1 \\ \hline
zeroin.i.2 & 211 & 3541 & 0.17 & 3.82 & 1 \\ \hline
zeroin.i.3 & 206 & 3540 & 0.25 & 1.91 & 1 \\ \hline
\end{tabular}
\end{table}


