\section{Conclusión}

El famoso problema de coloreo de grafos, que ha sido estudiado ampliamente en la literatura, es un caso particular del coloreo particionado de grafos, donde cada vértice pertenece a una partición diferente. Por esta razón, en primer lugar notamos que el problema del coloreo particionado iba a ser al menos tan difícil como el problema de coloreo, que ya en si es un problema sumamente complicado.

Las desigualdades de planos de cortes que se han implementado en este trabajo son desigualdades utilizadas normalmente para coloreo. Por esta razón, notamos a lo largo de todo el trabajo que en general los algoritmos de Cut \& Branch funcionan bien a medida que aumenta el número de particiones. La intuición nos sugiere que deben existir mejores familias que exploten el hecho de que el grafo esté dividido en particiones, aunque encontrarlas escape del alcance de este trabajo \cite{coloring}.

Uno de los primeros problemas que encontramos al programar el algoritmo de Cut \& Branch fue tener buenas heurísticas para las familias de desigualdades que probamos válidas. Aquí es donde interviene sin duda la creatividad del investigador para diseñar estas heurísticas, principalmente porque se sabe que generarlas de manera exhaustiva es un problema NP-Hard. A lo largo de este trabajo probamos varias estrategias, y finalmente nos quedamos con una que depende de la solución de la relajación en cada iteración. Sin embargo, no tenemos ninguna duda de que existen heurísticas mucho más efectivas. A su vez, una vez encontrado este conjunto de desigualdades violadas, es sumamente importante establecer un criterio para decidir cuáles deben ser agregadas al programa lineal. Se pudo comprobar, en términos generales, que agregarlas todas hace que la optimización sea más lenta.

Por otro lado, en general notamos que el tiempo de cómputo no está dominado por la generación de estas familias, sino por la resolución del programa lineal. Probablemente esto no siempre sea cierto, y el investigador deba procurar un balance entre el tiempo de ejecución de la heurística y el tiempo de ejecución necesario para resolver el programa lineal. Por ejemplo, si consideramos el caso extremo donde generamos la familia entera, este problema es no polinomial, y seguramente dominará el tiempo de ejecución.

A lo largo de este trabajo, la performance de CPLEX nos sorprendió notablemente. Por default, CPLEX en sí funciona bastante bien. Conseguir una mejor descripción de la cápsula convexa muchas veces es muy difícil, y \textit{en términos prácticos} puede llegar a no valer la pena. Debe balancearse el esfuerzo y la dificultad con el tiempo de cómputo y la calidad de la solución obtenido. Por supuesto, también influye el tamaño de instancia que uno necesite resolver. Aquí es donde entra CPLEX, que con una formulación simple del PPL logra optimizar el problema relativamente bien para instancias razonablemente chicas. Como comentario, comprobamos la suma importancia de romper con la simetría de los problemas. Esto en general no representa mucha dificultad, y mejora los tiempos de ejecución de forma considerable.

Una posible mejora para resolver este problema sería implementar un algoritmo Branch \& Cut, buscando buenas heurísticas iniciales y primales para el cálculo de cotas del óptimo, y haciendo cortes en cada nodo del árbol utilizando los \textit{callbacks} de CPLEX \cite{cplex}. Asimismo, podrían incluirse estrategias de preprocesamiento.

Existe gran cantidad de parámetros a calibrar para lograr una buena performance, y su elección en general se basa en una experimentación que logre emular los casos más comunes en la práctica. Durante este trabajo, no se experimentó en profundidad con instancias y problemas sumamente difíciles, debido al tiempo acotado para realizar el mismo. Sería interesante, sin embargo, ver hasta qué punto pueden llegar los algoritmos con una buena configuración.