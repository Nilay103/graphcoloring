\section{Conclusión}

El famoso problema de coloreo de grafos, que ha sido estudiado ampliamente en la literatura, es un caso particular del coloreo particionado de grafos, donde cada vértice pertenece a una partición diferente. Por esta razón, en primer lugar notamos que el problema del coloreo particionado sería al menos tan difícil como el problema de coloreo estándar, que de por sí representa un problema complicado.

Las desigualdades de planos de cortes que se han implementado en este trabajo son desigualdades utilizadas normalmente para coloreo. Por esta razón, a lo largo de todo el trabajo hemos notado que los algoritmos de Cut \& Branch tienden a funcionar mejor en los casos en que la relación cantidad de particiones sobre cantidad de nodos es mayor. La intuición nos sugiere que deben existir mejores familias, que exploten el hecho de que el grafo esté dividido en particiones, si bien encontrarlas y desarrollarlas escape del alcance de este trabajo.

Uno de los primeros problemas que encontramos al programar el algoritmo de Cut \& Branch fue encontrar buenas heurísticas para las familias de desigualdades que probamos válidas. A priori sabíamos, por ejemplo, que generar todas las cliques de manera exhaustiva es un problema NP-Hard. Aquí es donde interviene sin duda la creatividad del investigador para el diseño de los algoritmos, y obtener una heurística que genere un buen resultado. A lo largo de este trabajo probamos varias estrategias, y finalmente nos quedamos con una que depende de la solución de la relajación en cada iteración. Sin embargo, no tenemos ninguna duda de que existen heurísticas mucho más efectivas. A su vez, una vez encontrado este conjunto de desigualdades violadas, es sumamente importante establecer un criterio para decidir cuáles deben ser agregadas al programa lineal. Se pudo comprobar, en términos generales, que agregarlas todas hace que la optimización sea más lenta.

Por otro lado, en nuestro caso hemos notado que el tiempo de cómputo no está dominado por la generación de estas familias, sino por la resolución del programa lineal. La explicación más probable de esto es que el algoritmo de Cut \& Branch implementado realiza cortes únicamente en el nodo raíz (una o más iteraciones), por lo que la cantidad de llamados a las heurísticas no crece al recorrer el árbol. En el caso más general, esto no se cumple, y es tarea del investigador procurar un balance entre el tiempo de ejecución de la heurística y el tiempo de ejecución necesario para resolver el programa lineal. Por supuesto, también es importante descubrir en qué tipos de problemas (tamaño, características particulares, etc) conviene utilizar determinadas estrategias como cortes específicos, o diferentes modos de recorrer el árbol de enumeración. En definitiva, el diseño del algoritmo requiere conocer las distintas variables intervinientes, y cómo éstas afectan el resultado final. Es por ello que las horas experimentación con diversas instancias son una etapa clave para conocer el proceso y poder refinarlo. Posteriormente, se podrá acomodarlo o refinarlo, para obtener buenos resultados ya sea en una instancia en particular, o en términos más generales de aplicación.

A lo largo de este trabajo, la performance de CPLEX nos sorprendió notablemente. Por default, CPLEX en sí funciona bastante bien. Conseguir una mejor descripción de la cápsula convexa muchas veces es difícil, y \textit{en términos prácticos} puede llegar a no valer la pena. Debe balancearse el esfuerzo y la dificultad con el tiempo de cómputo y la calidad de la solución obtenida. Por supuesto, también influye el tamaño de instancia que uno necesite resolver. Aquí es donde entra CPLEX, que con una formulación simple del PPL logra optimizar el problema relativamente bien para instancias razonablemente chicas. Como comentario, comprobamos la suma importancia de romper con la simetría de los problemas. Esto en general no representa gran dificultad adicional, y mejora los tiempos de ejecución de forma considerable.

En cuanto a oportunidades de mejora, se podría generalizar el algoritmo Branch \& Cut, agregando heurísticas iniciales y primales (qué mejoran el cálculo de cotas, la inicialización y la poda de ramas), o encontrando mejores estrategias de cortes en diferentes partes del árbol, utilizando los \textit{callbacks} de CPLEX. Asimismo, podrían incluirse estrategias de preprocesamiento.

Existe gran cantidad de parámetros a calibrar para lograr una buena performance, y su elección en general se basa en una experimentación que logre emular los casos más comunes en la práctica. Durante este trabajo, no se experimentó en profundidad con instancias y problemas sumamente difíciles debido al tiempo acotado para realizar el mismo. Sería interesante, sin embargo, ver hasta qué punto pueden llegar los algoritmos con una buena configuración.