\section{Conclusión}

El famoso problema de coloreo de grafos, el cual ha sido estudiado ampliamente en la literatura, es un caso particular del coloreo particionado de grafos, donde cada vértice pertenece a una partición diferente. Por esta razón, en primer lugar notamos que el problema del coloreo particionado iba a ser al menos tan difícil como el problema de coloreo, que ya en si es un problema sumamente complicado.

Las desigualdades de planos de cortes que hemos implementado en este trabajo son desigualdades utilizadas normalmente para coloreo. Por esta razón notamos a lo largo de todo el trabajo que en general los algoritmos de Cut \& Branch funcionan bien a medida que aumenta el numero de particiones. La intuición nos dice que deben existir mejores familias que exploten el hecho de que el grafo este dividido en particiones, aunque encontrarlas escapa el objetivo de este trabajo \cite{coloring}.

Uno de los primeros problemas que nos encontramos al programar el algoritmo de Cut \& Branch fue buscar buenas heurísticas para las familias de desigualdades que probamos validas. Aquí es donde claramente entra la creatividad del investigador para diseñar estas heurísticas, principalmente porque generar estas familias de forma exhaustiva es un problema NP-Hard. A lo largo de este trabajo probamos varias estrategias, y finalmente nos quedamos con una que depende de la solución de la relajación en cada iteración. Sin embargo, no tenemos ninguna duda de que existen heurísticas mucho mas efectivas. A su vez, una vez encontrado este conjunto de desigualdades violadas, es sumamente importante encontrar un criterio para decidir cuales deben ser agregadas al programa lineal, dado que agregar todas en general hace que la optimización sea mas lenta.

Por otro lado, en general notamos que el tiempo de computo no esta dominado por la generación de estas familias, si no que por la resolución del programa lineal. Probablemente esto no siempre es cierto, y el investigador debe buscar un balance entre el tiempo de ejecución de la heurística y el tiempo que el programa lineal necesita luego para ser ejecutado. Por ejemplo, si consideramos el caso extremo donde generamos la familia entera, este problema es no polinomial y seguramente dominara el tiempo de ejecución.

Durante este trabajo, la performance de CPLEX nos sorprendió ampliamente. Por default, CPLEX en si funciona bastante bien. Buscar una mejor descripción de la cápsula convexa muchas veces es muy difícil y \textit{en términos prácticos} puede llegar a no valer la pena dependiendo del tamaño de instancia que se quiera resolver. Aquí es donde entra CPLEX, que con una simple formulación del programa lineal logra optimizar el problema relativamente bien para instancias razonablemente chicas. Un comentario, es muy importante buscar romper con la simetría de los problemas. Esto en general no es muy difícil y mejora los tiempos de ejecución de forma considerable.

Una posible mejora para resolver este problema es implementar un algoritmo Branch \& Cut, buscando buenas heurísticas iniciales y primales para el calculo de cotas del óptimo y haciendo cortes en cada nodo del árbol utilizando los \textit{callbacks} de CPLEX \cite{cplex}.

Existe una gran cantidad de parámetros a calibrar para lograr una buena performance, y su elección en general se basa en una experimentación que logre emular los casos mas comunes en la practica. Durante este trabajo no trabajamos mucho con instancias y problemas sumamente difíciles dado el tiempo acotado para realizar el mismo, aunque seria interesante ver hasta que punto pueden llegar los algoritmos con una buena configuración.